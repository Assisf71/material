<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="pt-br">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <meta name="google-site-verification" content="3wpHHnuvp_52dDrXvZoNa5_Vs4BWcyVoeM62GbQ7llc" />
    <title>Purrr - Curso-R</title>
    <meta name="generator" content="Hugo 0.22" />

    
    <meta name="description" content="Materiais para cursos de R">
    
    <link rel="canonical" href="../purrr/">
    
    <meta name="author" content="Curso-R">
    

    <meta property="og:url" content="/purrr/">
    <meta property="og:title" content="Curso-R">
    <meta property="og:image" content="/logo-curso-r.png">
    <meta name="apple-mobile-web-app-title" content="Curso-R">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="//images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="//images/favicon.ico">
    <link href="../stylesheets/prism/prism.css" rel="stylesheet" />
    <link rel="stylesheet" href="../stylesheets/icons.css">
    <link rel="stylesheet" href="../stylesheets/application.css">
    <link rel="stylesheet" href="../stylesheets/temporary.css">
    <link rel="stylesheet" href="../stylesheets/palettes.css">
    <link rel="stylesheet" href="../stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="../javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-red palette-accent-teal">



	
	


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
        <a href="../" class="permalink">Curso-R</a>
        
      </div>
    </div>

    
    <div class="button button-twitter" role="button" aria-label="Twitter">
       <a href="https://twitter.com/curso_r" title="@curso_r on Twitter" target="_blank" class="toggle-button icon icon-twitter"></a>
    </div>
    
    
    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/curso-r" title="@curso-r on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>

</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="../" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="../logo-curso-r.png">
        </div>
      
      <div class="name">
        <strong>Curso-R </strong>
        
          <br>
          curso-r/material
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            <a href="https://github.com/curso-r/material/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/curso-r/material/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="Instalação" href="../instalacao/">
	
	Instalação
</a>



  
</li>



<li>
  
    



<a  title="R básico" href="../rbase/">
	
	R básico
</a>



  
</li>



<li>
  
    



<a  title="Pipe" href="../pipe/">
	
	Pipe
</a>



  
</li>



<li>
  
    



<a  title="Importação" href="../import/">
	
	Importação
</a>



  
</li>



<li>
  
    



<a  title="Manipulação" href="../manip/">
	
	Manipulação
</a>



  
</li>



<li>
  
    



<a  title="Visualizações" href="../ggplot/">
	
	Visualizações
</a>



  
</li>



<li>
  
    



<a  title="Strings" href="../stringr/">
	
	Strings
</a>



  
</li>



<li>
  
    



<a  title="Datas" href="../lubridate/">
	
	Datas
</a>



  
</li>



<li>
  
    



<a  title="Fatores" href="../forcats/">
	
	Fatores
</a>



  
</li>



<li>
  
    



<a class="current" title="Programação Funcional" href="../purrr/">
	
	Programação Funcional
</a>


<ul id="scrollspy">
</ul>


  
</li>



<li>
  
    



<a  title="Modelagem" href="../modelos/">
	
	Modelagem
</a>



  
</li>



<li>
  
    



<a  title="Shiny" href="../shiny/">
	
	Shiny
</a>



  
</li>



<li>
  
    



<a  title="APIs" href="../api/">
	
	APIs
</a>



  
</li>



<li>
  
    



<a  title="Web Scraping" href="../scrape/">
	
	Web Scraping
</a>



  
</li>


        </ul>
        

        
        <hr>
        <span class="section">Vamos trocar uma ideia?</span>
        
        <ul>
          
          <li>
            <a href="https://twitter.com/curso_r" target="_blank" title="Twitter">
              Twitter
            </a>
          </li>
          
          
          
          <li>
            <a href="https://www.facebook.com/cursodeR" target="_blank" title="Facebook">
              Facebook
            </a>
          </li>
          

          
          <li>
            <a href="https://github.com/curso-r" target="_blank" title="GitHub">
              GitHub
            </a>
          </li>
          

          
          <li>
            <a href="mailto:contato@curso-r.com" title="Email of contato@curso-r.com">
              E-mail
            </a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1> Purrr </h1>

			

<p>Programação funcional (PF) é um paradigma de programação com o qual a maior parte
dos estatísticos não está familiarizada. Essa técnica costuma ser ignorada na
maioria dos tutoriais de R por não estar diretamente envolvida com manipulação e
visualização de dados, mas isso não quer dizer que ela não tenha suas vantagens.</p>

<p>Usando PF podemos criar códigos mais concisos e &ldquo;pipeáveis&rdquo;, características que
por tabela também tornam o processo de debug mais simples. Além disso, códigos
funcionais geralmente são paralelizáveis, permitindo que tratemos problemas muito
grandes com poucas modificações.</p>

<p>Apesar de o R <code>base</code> já ter funções que podem ser consideradas elementos de PF, a
implementação destas não é tão elegante e, portanto, este tutorial abordará
somente a implementação de PF realizada pelo pacote <code>purrr</code>.</p>

<p>Para instalar e carregar o <code>purrr</code>, rode o código a seguir. Nas próximas seções
deste tutorial, assumiremos que você têm esse pacote instalado e carregado.</p>

<pre><code class="language-r">install.packages(&quot;purrr&quot;)
library(purrr)
</code></pre>

<hr />

<h2 id="iterações-básicas">Iterações básicas</h2>

<p>A primeira família de funções do <code>purrr</code> que veremos também é a mais útil e
extensível. As funções <code>map()</code> são quase como substitutas para laços <code>for</code>,
elas abstraem a iteração em apenas uma linha. Veja esse exemplo de laço usando
<code>for</code>:</p>

<pre><code class="language-r">soma_um &lt;- function(x) { x + 1 }
obj &lt;- 10:15

for (i in seq_along(obj)) {
  obj[i] &lt;- soma_um(obj[i])
}
obj
## [1] 11 12 13 14 15 16
</code></pre>

<p>O que de fato estamos tentando fazer com o laço acima? Temos um vetor (<code>obj</code>) e
queremos aplicar uma função (<code>soma_um()</code>) em cada elemento dele. A função <code>map()</code>
remove a necessidade de declaramos um objeto iterador auxiliar (<code>i</code>) e
simplesmente aplica a função desejada em cada elemento do objeto dado.</p>

<pre><code class="language-r">soma_um &lt;- function(x) { x + 1 }
obj &lt;- 10:15

obj &lt;- map(obj, soma_um)
obj
## [[1]]
## [1] 11
## 
## [[2]]
## [1] 12
## 
## [[3]]
## [1] 13
## 
## [[4]]
## [1] 14
## 
## [[5]]
## [1] 15
## 
## [[6]]
## [1] 16
</code></pre>

<h3 id="achatando-resultados">Achatando resultados</h3>

<p>Como você deve ter percebido, o resultado da execução acima não é exatamente
igual ao que tivemos com o laço. Isso acontece porque a <code>map()</code> tenta ser
extremamente genérica, retornando por padrão uma lista com um elemento para
cada saída.</p>

<p>Se quisermos &ldquo;achatar&rdquo; o resultado, devemos informar qual será o seu tipo. Isso
é super simples e pode ser feito com as irmãs da <code>map()</code>: <code>map_chr()</code> (para
strings), <code>map_dbl()</code> (para números reais), <code>map_int()</code> (para números inteiros) e
<code>map_lgl()</code> (para booleanos).</p>

<pre><code class="language-r">obj &lt;- 10:15

map_dbl(obj, soma_um)
## [1] 11 12 13 14 15 16
</code></pre>

<div class='admonition note'>
<p class='admonition-title'>
Outro jeito de achatar
</p>
<p>
O <code>purrr</code> também nos fornece outra ferramenta interessante para
achatar listas: a família <code>flatten()</code>. No fundo, <code>map_chr()</code>
é quase um atalho para <code>map() %>% flatten_chr()</code>!
</p>
</div>

<h3 id="fórmulas-e-reticências">Fórmulas e reticências</h3>

<p>Algo bastante útil da família <code>map()</code> é a possibilidade de passar argumentos
fixos para a função que será aplicada. A primeira forma de fazer isso envolve
fórmulas:</p>

<pre><code class="language-r">soma_n &lt;- function(x, n = 1) { x + n }
obj &lt;- 10:15

map_dbl(obj, ~soma_n(.x, 2))
## [1] 12 13 14 15 16 17
</code></pre>

<p>Como vemos no exemplo acima, para utilizar fórmulas precisamos colocar um til
(<code>~</code>) antes da função que será chamada. Feito isso, podemos utilizar o
placeholder <code>.x</code> para indicar onde deve ser colocado cada elemento de <code>obj</code>.</p>

<p>A outra forma de passar argumentos para a função é através das reticências da
<code>map()</code>. Desta maneira precisamos apenas dar o nome do argumento e seu valor
logo após a função <code>soma_n()</code>.</p>

<pre><code class="language-r">soma_n &lt;- function(x, n = 1) { x + n }
obj &lt;- 10:15

map_dbl(obj, soma_n, n = 2)
## [1] 12 13 14 15 16 17
</code></pre>

<p>Usando fórmulas temos uma maior flexibilidade (podemos, por exemplo, declarar
funções anônimas como <code>~.x+2</code>), enquanto com as reticências temos maior
legibilidade.</p>

<hr />

<h2 id="iterações-intermediárias">Iterações intermediárias</h2>

<p><strong>Obs.:</strong> Note que quando usarmos o termo &ldquo;paralelo&rdquo; daqui para frente, estaremos
nos referindo a laços em mais de uma estrutura e não a paralelização de
computações em mais de uma unidade de processamento.</p>

<p>Agora que já exploramos os básicos da família <code>map()</code> podemos partir para
iterações um pouco mais complexas. Observe o laço a seguir:</p>

<pre><code class="language-r">soma_ambos &lt;- function(x, y) { x + y }
obj_1 &lt;- 10:15
obj_2 &lt;- 20:25

for (i in seq_along(obj_1)) {
  obj_1[i] &lt;- soma_ambos(obj_1[i], obj_2[i])
}
obj_1
## [1] 30 32 34 36 38 40
</code></pre>

<p>Com a função <code>map2()</code> podemos reproduzir o laço acima em apenas uma linha. Ela
abstrai a iteração em paralelo, aplica a função em cada par de elementos das
entradas e, assim como sua prima <code>map()</code>, pode achatar o objeto retornado com os
sufixos <code>_chr</code>, <code>_dbl</code>, <code>_int</code> e <code>_lgl</code>.</p>

<pre><code class="language-r">soma_ambos &lt;- function(x, y) { x + y }
obj_1 &lt;- 10:15
obj_2 &lt;- 20:25

obj_1 &lt;- map2_dbl(obj_1, obj_2, soma_ambos)
obj_1
## [1] 30 32 34 36 38 40
</code></pre>

<p>Como o pacote <code>purrr</code> é extremamente consistente, a <code>map2()</code> também funciona com
reticências e fórmulas. Poderíamos, por exemplo, transformar <code>soma_ambos()</code> em
uma função anônima:</p>

<pre><code class="language-r">obj_1 &lt;- 10:15
obj_2 &lt;- 20:25

map2_dbl(obj_1, obj_2, ~.x+.y)
## [1] 30 32 34 36 38 40
</code></pre>

<p>Desta vez também temos acesso ao placeholder <code>.y</code> para indicar onde os elementos
de do segundo vetor devem ir.</p>

<h3 id="generalização-do-paralelismo">Generalização do paralelismo</h3>

<p>Para não precisar oferecer uma função para cada número de argumentos, o pacote
<code>purrr</code> fornece a <code>pmap()</code>. Para essa função devemos passar uma lista em que cada
elemento é um dos objetos a ser iterado:</p>

<pre><code class="language-r">soma_varios &lt;- function(x, y, z) { x + y + z }
obj_1 &lt;- 10:15
obj_2 &lt;- 20:25
obj_3 &lt;- 30:35

obj_1 &lt;- pmap_dbl(list(obj_1, obj_2, obj_3), soma_varios)
obj_1
## [1] 60 63 66 69 72 75
</code></pre>

<p>Com a <code>pmap()</code> infelizmente não podemos usar fórmulas. Se quisermos usar uma
função anônima com ela, precisamos declará-la a função no seu corpo:</p>

<pre><code class="language-r">obj_1 &lt;- 10:15
obj_2 &lt;- 20:25
obj_3 &lt;- 30:35

pmap_dbl(list(obj_1, obj_2, obj_3), function(x, y, z) { x + y + z })
## [1] 60 63 66 69 72 75
</code></pre>

<h3 id="iterando-em-índices">Iterando em índices</h3>

<p>A última função que veremos nessa seção é a <code>imap()</code>. No fundo ela é um
atalho para <code>map2(x, names(x), ...)</code> quando <code>x</code> tem nomes e para
<code>map2(x, seq_along(x), ...)</code> caso contrário:</p>

<pre><code class="language-r">obj &lt;- 10:15

imap_dbl(obj, ~.x+.y)
## [1] 11 13 15 17 19 21
</code></pre>

<p>Como podemos observar, agora <code>.y</code> é o placeholder para o índice atual (equivalente
ao <code>i</code> no laço com <code>for</code>). Naturalmente, assim como toda a família <code>map()</code>, a
<code>imap()</code> também funciona com os sufixos de achatamento.</p>

<hr />

<h2 id="iterações-avançadas">Iterações avançadas</h2>

<p>Agora que já vimos como substituir iterações de nível básico e de nível
intermediário com a família <code>map()</code>, podemos passar para os tipos mais obscuros
de laços. Cada item desta seção será mais denso do que os das passadas, por isso
encorajamos todos os leitores para que também leiam a documentação de cada função
aqui abordada.</p>

<h3 id="iterações-com-condicionais">Iterações com condicionais</h3>

<p>Imagine que precisamos aplicar uma função somente em alguns elementos de um vetor.
Com um laço isso é uma tarefa fácil, mas com as funções da família <code>map()</code>
apresentadas até agora isso seria extremamente difícil. Veja o trecho de código
a seguir por exemplo:</p>

<pre><code class="language-r">dobra &lt;- function(x) { x*2 }
obj &lt;- 10:15

for (i in seq_along(obj)) {
  if (obj[i] %% 2 == 1) { obj[i] &lt;- dobra(obj[i]) }
  else                  { obj[i] &lt;- obj[i] }
}
obj
## [1] 10 22 12 26 14 30
</code></pre>

<p>No exemplo acima, aplicamos a função <code>dobra()</code> apenas nos elementos ímpares do
vetor <code>obj</code>. Com o pacote <code>purrr</code> temos duas maneiras de fazer isso: com
<code>map_if()</code> ou <code>map_at()</code>.</p>

<p>A primeira dessas funções aplica a função dada apenas quando um predicado é
<code>TRUE</code>. Esse predicado pode ser uma função ou uma fórmula (que serão aplicadas
em cada elemento da entrada e devem retornar <code>TRUE</code> ou <code>FALSE</code>). Infelizmente
a <code>map_if()</code> não funciona com sufixos, então devemos achatar o resultado:</p>

<pre><code class="language-r">eh_impar &lt;- function(x) { x%%2 == 1 }
dobra &lt;- function(x) { x*2 }
obj &lt;- 10:15

map_if(obj, eh_impar, dobra) %&gt;% flatten_dbl()
## [1] 10 22 12 26 14 30
</code></pre>

<p>Com fórmulas poderíamos eliminar completamente a necessidade de funções
declaradas:</p>

<pre><code class="language-r">obj &lt;- 10:15

map_if(obj, ~.x%%2 == 1, ~.x*2) %&gt;% flatten_dbl()
## [1] 10 22 12 26 14 30
</code></pre>

<p>A segunda dessas funções é a irmã gêmea de <code>map_if()</code> e funciona de forma muito
semelhante. Para <code>map_at()</code> devemos passar um vetor de nomes ou índices onde a
função deve ser aplicada:</p>

<pre><code class="language-r">obj &lt;- 10:15

map_at(obj, c(2, 4, 6), ~.x*2) %&gt;% flatten_dbl()
## [1] 10 22 12 26 14 30
</code></pre>

<h3 id="iterações-com-tabelas-e-funções">Iterações com tabelas e funções</h3>

<p>Duas funções menos utilizadas da família <code>map()</code> são <code>map_dfc()</code> e <code>map_dfr()</code>,
que equivalem a um <code>map()</code> seguido de um <code>dplyr::bind_cols()</code> ou de um
<code>dplyr::bind_rows()</code> respectivamente.</p>

<div class='admonition note'>
<p class='admonition-title'>
Lendo múltiplas tabelas
</p>
<p>
A maior utilidade dessas funções é quando temos uma tabela espalhada em muitos
arquivos. Se elas estiverem divididas por grupos de colunas, podemos usar algo
como <code>map_dfc(arquivos, readr::read_csv)</code> e se elas estiverem
divididas por grupos de linhas, <code>map_dfr(arquivos, readr::read_csv)</code>
</p>
</div>

<p>Outro membro obscuro da família <code>map()</code> é a <code>invoke_map()</code>. Na verdade essa
função pode ser considerada um membro da família <code>invoke()</code>, mas vamos ver
que as semelhanças são muitas. Primeiramente, vamos demonstrar o que faz a
<code>invoke()</code> sozinha:</p>

<pre><code class="language-r">soma_ambos &lt;- function(x, y) { x + y }

invoke(soma_ambos, list(x = 10, y = 15))
## [1] 25
</code></pre>

<p>É fácil de ver que essa função recebe uma função e uma lista de argumentos para
usar em uma chamada desta. Agora generalizando esta lógica temos <code>invoke_map()</code>,
que chama uma mesma função com uma lista de listas de argumentos ou uma lista
de funções com uma lista de argumentos. A família <code>invoke()</code> também aceita os
sufixos como veremos a seguir:</p>

<pre><code class="language-r">soma_ambos &lt;- function(x, y) { x + y }
soma_um &lt;- function(x) { x + 1 }
soma_dois &lt;- function(x) { x + 2 }

invoke_map_dbl(soma_ambos, list(list(x = 10, y = 15), list(x = 20, y = 25)))
## [1] 25 45

invoke_map_dbl(list(soma_um, soma_dois), list(x = 10))
## [1] 11 12
</code></pre>

<h3 id="redução-e-acúmulo">Redução e acúmulo</h3>

<p>Outras funções simbólicas de programação funcional além da <code>map()</code> são <code>reduce</code>
e <code>accumulate</code>, que aplicam transformações em valores acumulados. Observe o laço
a seguir:</p>

<pre><code class="language-r">soma_ambos &lt;- function(x, y) { x + y }
obj &lt;- 10:15

for (i in 2:length(obj)) {
  obj[i] &lt;- soma_ambos(obj[i-1], obj[i])
}
obj
## [1] 10 21 33 46 60 75
</code></pre>

<p>Essa soma cumulativa é bastante simples, mas não é difícil imaginar uma situação
em que um programador desavisado confunde um índice com o outro e o bug acaba
passando desapercebido. Para evitar esse tipo de situação, podemos utilizar
<code>accumulate()</code> (tanto com uma função quanto com uma fórmula):</p>

<pre><code class="language-r">soma_ambos &lt;- function(x, y) { x + y }
obj &lt;- 10:15

accumulate(obj, soma_ambos)
## [1] 10 21 33 46 60 75

accumulate(obj, ~.x+.y)
## [1] 10 21 33 46 60 75
</code></pre>

<p><strong>Obs.:</strong> Nesse caso, os placeholders têm significados ligeiramente diferentes.
Aqui, <code>.x</code> é o valor acumulado e <code>.y</code> é o valor &ldquo;atual&rdquo; do objeto sendo iterado.</p>

<p>Se não quisermos o valor acumulado em cada passo da iteração, podemos usar
<code>reduce()</code>:</p>

<pre><code class="language-r">obj &lt;- 10:15

reduce(obj, ~.x+.y)
## [1] 75
</code></pre>

<p>Para a nossa comodidade, essas duas funções também têm variedades paralelas
(<code>accumulate2()</code> e <code>reduce2()</code>), assim como variedades invertidas
<code>accumulate_right()</code> e <code>reduce_right()</code>).</p>

<hr />

<h2 id="miscelânea">Miscelânea</h2>

<p>Por fim, veremos algumas funções do <code>purrr</code> que nêo têm exatamente a ver com
laços, mas que acabam sendo bastante úteis quando usando as funções que vimos
até agora. Elas não serão apresentadas em nenhuma ordem específica, este é apenas
um apanhado de funções sortidas que achamos úteis enquanto programando com o
<code>purrr</code>.</p>

<h3 id="manter-e-descartar">Manter e descartar</h3>

<p>Se quisermos filtrar elementos de um vetor ou lista, podemos usar as funções
<code>keep()</code> e <code>discard()</code>. Elas funcionam com fórmulas e podem ser extremamente úteis
em situações que <code>dplyr::select()</code> e <code>magrittr::extract()</code> não conseguem cobrir:</p>

<pre><code class="language-r">obj &lt;- list(10:15, 20:25, c(30:34, NA))

keep(obj, ~any(is.na(.x)))
## [[1]]
## [1] 30 31 32 33 34 NA

discard(obj, ~!any(is.na(.x)))
## [[1]]
## [1] 30 31 32 33 34 NA
</code></pre>

<p>No exemplo acima descartamos todos os vetores da lista que não têm pelo menos um
elemento omisso (<code>NA</code>).</p>

<h3 id="a-família-is">A família <code>is</code></h3>

<p>Uma outra família do pacote <code>purrr</code> é a <code>is()</code>. Com essa série de funções podemos
fazer verificações extremamente estritas em objetos dos mais variados tipos. Seguem
alguns poucos exemplos:</p>

<pre><code class="language-r">is_scalar_integer(10:15)
## [1] FALSE

is_bare_integer(10:15)
## [1] TRUE

is_atomic(10:15)
## [1] TRUE

is_vector(10:15)
## [1] TRUE
</code></pre>

<h3 id="andar-e-modificar">Andar e modificar</h3>

<p><code>walk()</code> e <code>modify()</code> são pequenas alterações da família <code>map()</code> que vêm a calhar
em diversas situações. A primeira destas funciona exatamente igual à <code>map()</code> mas
não devolve resultado, apenas efeitos colaterais; a segunda, não muda a
estrutura do objeto sendo iterado, ela substitui os próprios elementos da entrada.</p>

<div class='admonition note'>
<p class='admonition-title'>
Escrevendo múltiplas tabelas
</p>
<p>
A maior utilidade de <code>walk</code> é quando precisamos salvar múltiplas
tabelas. Para fazer isso, podemos usar algo como
<code>walk(tabelas, readr::write_csv)</code>.
</p>
</div>

<p>Um caso de uso interessante da <code>modify()</code> é quando junta do sufixo <code>_if()</code>,
combinação que nos permite iterar nas colunas de uma tabela e aplicar
transformações de tipo apenas quando um predicado for verdade (geralmente de
queremos transformar as colunas de fator para caractere).</p>

<h3 id="transposição-e-indexação-profunda">Transposição e indexação profunda</h3>

<p>Quando precisarmos lidar com listas complexas e profundas, o <code>purrr</code> nos fornece
duas funções extremamente úteis: <code>transpose()</code> e <code>pluck()</code>. A primeira transpõe
uma lista, enquanto a segunda é capaz de acessar elementos profundos de uma lista
sem a necessidade de colchetes.</p>

<pre><code class="language-r">obj &lt;- list(list(a = 1, b = 2, c = 3), list(a = 4, b = 5, c = 6))
str(obj)
## List of 2
##  $ :List of 3
##   ..$ a: num 1
##   ..$ b: num 2
##   ..$ c: num 3
##  $ :List of 3
##   ..$ a: num 4
##   ..$ b: num 5
##   ..$ c: num 6

pluck(obj, 2, &quot;b&quot;)
## [1] 5

str(transpose(obj))
## List of 3
##  $ a:List of 2
##   ..$ : num 1
##   ..$ : num 4
##  $ b:List of 2
##   ..$ : num 2
##   ..$ : num 5
##  $ c:List of 2
##   ..$ : num 3
##   ..$ : num 6
</code></pre>

<p><strong>Obs.:</strong> Se você estiver com muitos problemas com listas profundas, dê uma olhada
nas funções relacionadas a <code>depth()</code> pois elas podem ser muito úteis.</p>

<h3 id="aplicação-parcial">Aplicação parcial</h3>

<p>Se quisermos pré-preencher os argumentos de uma função (seja para usá-la em uma
pipeline ou com alguma função do próprio <code>purrr</code>), temos <code>partial()</code>. Ela funciona
nos moldes da família <code>invoke()</code> e pode ser bastante útil para tornar suas
pipelines mais enxutas:</p>

<pre><code class="language-r">soma_varios &lt;- function(x, y, z) { x + y + z }

nova_soma &lt;- partial(soma_varios, x = 1, y = 2)
nova_soma(3)
## [1] 6
</code></pre>

<h3 id="execução-segura">Execução segura</h3>

<p>Não é incomum executarmos uma função e recebermos um erro de volta. Isso pode ser
lidado com facilidade em um laço com um condicional, mas essa tarefa já é mais
complexa quando se trata de programação funcional. Para isso, no <code>purrr</code> temos
algumas funções que embrulham uma função e, quando esta retornar um erro, o
silenciam e retornam um valor padrão em seu lugar.</p>

<p><code>quietly()</code> retorna uma lista com resultado, saída, mensagem e alertas, <code>safely()</code>
retorna uma lista com resultado e erro (um destes sempre é <code>NULL</code>), e <code>possibly()</code>
silencia o erro e retorna um valor dado pelo usuário.</p>

<pre><code class="language-r">soma_um &lt;- function(x) { x + 1 }
s_soma_um &lt;- safely(soma_um, 0)
obj &lt;- c(10, 11, &quot;a&quot;, 13, 14, 15)

s_soma_um(obj)
## $result
## [1] 0
## 
## $error
## &lt;simpleError in x + 1: non-numeric argument to binary operator&gt;
</code></pre>

<hr />


			<aside class="copyright" role="note">
				
				&copy; 2017 Disponível sobre Licença MIT &ndash;
				
				Site built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="../ggplot/" title="Visualizações">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              Visualizações
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="../import/" title="Importação de dados">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              Importação de dados
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '\/';
      var repo_id  = 'curso-r\/material';
    
    </script>
    
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="../javascripts/application.js"></script>
    <script src="../javascripts/datacamp.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var div_h2    = document.getElementsByClassName("section level2")
      var headers   = document.getElementsByTagName("h2");	
      var scrollspy = document.getElementById('scrollspy');
      
      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");


	    if(headers[i].id == ""){
	     a.setAttribute("href", "#" + div_h2[i].id);
	    } else {
	     a.setAttribute("href", "#" + headers[i].id);
	    }

            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;
            
            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }
      }
      
      
      /* Add permanent link next to the headers */
      var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

      for(var i = 0; i < headers.length; i++) {
          var a = document.createElement("a");
          a.setAttribute("class", "headerlink");
          a.setAttribute("href", "#" + headers[i].id);
          a.setAttribute("title", "Permanent link")
          a.innerHTML = "%\u003e%";
          headers[i].appendChild(a);
      }
    </script>

    
      <script>
        (function(i,s,o,g,r,a,m){
          i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||
          []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
          m.parentNode.insertBefore(a,m)
        })(window, document,
          'script', '//www.google-analytics.com/analytics.js', 'ga');
         
        ga('create', 'UA-87272102-1', 'auto');
        ga('set', 'anonymizeIp', true);
        ga('send', 'pageview');
         
        var buttons = document.querySelectorAll('a');
        Array.prototype.map.call(buttons, function(item) {
          if (item.host != document.location.host) {
            item.addEventListener('click', function() {
              var action = item.getAttribute('data-action') || 'follow';
              ga('send', 'event', 'outbound', action, item.href);
            });
          }
        });
         
        var query = document.querySelector('.query');
        query.addEventListener('blur', function() {
          if (this.value) {
            var path = document.location.pathname;
            ga('send', 'pageview', path + '?q=' + this.value);
          }
        });
      </script>
    

    <script src="//gohugo.io/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../javascripts/prism.js"></script> 
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
        }
      });
      </script>
    
    <script type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
    </script>
    
    
  </body>
</html>

